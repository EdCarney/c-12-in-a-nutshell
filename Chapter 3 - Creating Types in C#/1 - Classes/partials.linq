<Query Kind="Statements" />


// PARTIAL TYPES and METHODS
//
// these allow a type definition to be split across multiple files to support user augmentation;
// note that all references must have the 'partial' declaration; there can be no member conflicts
//
// these types are resolved by the compiler, so all partial definitions must be available at
// compile time and must be in the same assembly
//
// a base class can be specified on one or more partial class declarations as long as the base
// class is the same
//
// partial methods allow a partial type to define customizable hooks for manual authoring; the
// DEFINITION is typically written by the code generator and the IMPLEMENTATION is manually
// authored; if no implementation is provided then the definition adn the code that calls it
// is compiled away
//
// partial methods allow for autogenerated code to provide many hooks that CAN be used, without
// worrying about bloating the compiled code
//
// partial methods must be void, are implicitly private, and cannot include out params


// EXTENDED PARTIAL METHODS
//
// from c#9, these are designed for REVERSE CODE GENERATION, where the programmer defines a hook that
// a code generator implements; for ex, with source generators
//
// a partial method is extended if it has ANY accessibility modifier
//
// extended partials MUST have implementations (they don't get compiled away if unimplemented); because
// of this, extended partials can also return any type and can also have out parameters

class MyBase { }
class MyOtherBase { }

interface IMyInterface { }
interface IMyOtherInterface { }

// PaymentFormGen.cs --> auto-generated from some template or designer
partial class PaymentForm : MyBase, IMyInterface
{
	// some auto-generated methods and properties
	
	// partial method DEFINITION
	partial void ValidatePayment(decimal amountUsd);
	
	// a partial method that we will not implement
	partial void DoSomethingUseless();
	
	// EXTENDED partial method definition
	public partial bool IsValid(string id);
}

// PaymentForm.cs --> my implemented type
//
// this type could (optionally) also inherit from MyBase, but it could not inherit from
// MyOtherBase since the other definition inherits from MyBase
//
// but, the partial definitions CAN inherit separate interfaces
partial class PaymentForm : IMyOtherInterface
{
	public PaymentForm()
	{
		Console.WriteLine("My custom logic here...");
	}
	
	// partial method IMPLEMENTATION
	partial void ValidatePayment(decimal amount)
	{
		if (amount > 100)
		{
			Console.WriteLine("Payment is good");
		}
	}
	
	// EXTENDED partial method implementation (required)
	public partial bool IsValid(string id) => id is null;
}